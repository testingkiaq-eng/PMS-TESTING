import type { CResult } from '../types.mts';
import type { SocketYml } from '@socketsecurity/config';
export interface LocalConfig {
    apiBaseUrl?: string | null | undefined;
    // @deprecated ; use apiToken. when loading a config, if this prop exists it
    //               is deleted and set to apiToken instead, and then persisted.
    //               should only happen once for legacy users.
    apiKey?: string | null | undefined;
    apiProxy?: string | null | undefined;
    apiToken?: string | null | undefined;
    defaultOrg?: string;
    enforcedOrgs?: string[] | readonly string[] | null | undefined;
    skipAskToPersistDefaultOrg?: boolean;
    org?: string; // convenience alias for defaultOrg
}
export type FoundSocketYml = {
    path: string;
    parsed: SocketYml;
};
export declare function findSocketYmlSync(dir?: string): FoundSocketYml | undefined;
export declare function getConfigValue<Key extends keyof LocalConfig>(key: Key): CResult<LocalConfig[Key]>;
// This version squashes errors, returning undefined instead.
// Should be used when we can reasonably predict the call can't fail.
export declare function getConfigValueOrUndef<Key extends keyof LocalConfig>(key: Key): LocalConfig[Key] | undefined;
export declare function getSupportedConfigEntries(): [keyof LocalConfig, string][];
export declare function getSupportedConfigKeys(): (keyof LocalConfig)[];
export declare function isReadOnlyConfig(): boolean;
export declare function isSensitiveConfigKey(key: string): key is keyof LocalConfig;
export declare function isSupportedConfigKey(key: string): key is keyof LocalConfig;
export declare function overrideCachedConfig(jsonConfig: unknown): CResult<undefined>;
export declare function overrideConfigApiToken(apiToken: unknown): void;
export declare function updateConfigValue<Key extends keyof LocalConfig>(configKey: keyof LocalConfig, value: LocalConfig[Key]): CResult<undefined | string>;
//# sourceMappingURL=config.d.mts.map